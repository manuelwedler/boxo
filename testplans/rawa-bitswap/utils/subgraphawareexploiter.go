package utils

import (
	"context"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/libp2p/go-libp2p/core/peer"
	bsmsg "github.com/manuelwedler/boxo/bitswap/message"
	bitswap_message_pb "github.com/manuelwedler/boxo/bitswap/message/pb"
	bsnet "github.com/manuelwedler/boxo/bitswap/network"
)

type SubgraphAwareWantForwardExploiter struct {
	lk           sync.RWMutex
	self         peer.AddrInfo
	network      bsnet.BitSwapNetwork
	ObservedCids map[cid.Cid]struct{}
	// want-haves are only sent by proxies in RaWa-Bitswap
	// we can only use one want-have cid for classification per peer
	// earlier requests are likelier coming from the predecessor
	WantHaveFromPeer  map[peer.ID]cid.Cid
	WantBlockFromPeer map[peer.ID]cid.Cid
	// Makes sure to only send a forward-have once for each request
	AnsweredRequests map[peer.ID]map[cid.Cid]struct{}
}

func NewSubgraphAwareWantForwardExploiter(self peer.AddrInfo, network bsnet.BitSwapNetwork) *SubgraphAwareWantForwardExploiter {
	exploiter := &SubgraphAwareWantForwardExploiter{
		self:              self,
		network:           network,
		ObservedCids:      make(map[cid.Cid]struct{}),
		WantHaveFromPeer:  make(map[peer.ID]cid.Cid),
		WantBlockFromPeer: make(map[peer.ID]cid.Cid),
		AnsweredRequests:  make(map[peer.ID]map[cid.Cid]struct{}),
	}

	return exploiter
}

func (sawfe *SubgraphAwareWantForwardExploiter) ReceiveMessage(_ context.Context, sender peer.ID, incoming bsmsg.BitSwapMessage) {
	sawfe.lk.Lock()
	defer sawfe.lk.Unlock()

	for _, e := range incoming.Wantlist() {
		sawfe.ObservedCids[e.Cid] = struct{}{}

		if e.WantType == bitswap_message_pb.Message_Wantlist_Block {
			sawfe.observedWantBlock(sender, e.Cid)
		} else if e.WantType == bitswap_message_pb.Message_Wantlist_Have {
			sawfe.observedWantHave(sender, e.Cid)
		}
	}
	for _, e := range incoming.Forwardlist() {
		sawfe.ObservedCids[e.Cid] = struct{}{}
		sawfe.sendResponse(sender, e.Cid)
	}
}

func (sawfe *SubgraphAwareWantForwardExploiter) observedWantBlock(sender peer.ID, c cid.Cid) {
	if _, ok := sawfe.WantBlockFromPeer[sender]; !ok {
		sawfe.WantBlockFromPeer[sender] = c
	}
}

func (sawfe *SubgraphAwareWantForwardExploiter) observedWantHave(sender peer.ID, c cid.Cid) {
	if _, ok := sawfe.WantHaveFromPeer[sender]; !ok {
		sawfe.WantHaveFromPeer[sender] = c
	}
}

func (sawfe *SubgraphAwareWantForwardExploiter) sendResponse(to peer.ID, c cid.Cid) {
	if _, ok := sawfe.AnsweredRequests[to]; !ok {
		sawfe.AnsweredRequests[to] = make(map[cid.Cid]struct{})
	}
	if _, ok := sawfe.AnsweredRequests[to][c]; ok {
		return
	}
	sawfe.AnsweredRequests[to][c] = struct{}{}

	go func(p peer.ID, k cid.Cid) {
		message := bsmsg.New(false)
		message.AddForwardHave(k, []peer.AddrInfo{sawfe.self})
		sawfe.network.SendMessage(context.Background(), p, message)
	}(to, c)
}

func (sawfe *SubgraphAwareWantForwardExploiter) ReceiveError(error) {}

func (sawfe *SubgraphAwareWantForwardExploiter) PeerConnected(peer.ID) {}

func (sawfe *SubgraphAwareWantForwardExploiter) PeerDisconnected(peer.ID) {}

// ensure SubgraphAwareWantForwardExploiter satisfies interface
var _ bsnet.Receiver = &SubgraphAwareWantForwardExploiter{}
