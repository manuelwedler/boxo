package utils

import (
	"context"
	"sync"

	"github.com/ipfs/go-cid"
	"github.com/libp2p/go-libp2p/core/peer"
	bsmsg "github.com/manuelwedler/boxo/bitswap/message"
	bitswap_message_pb "github.com/manuelwedler/boxo/bitswap/message/pb"
	bsnet "github.com/manuelwedler/boxo/bitswap/network"
)

type WantForwardExploiter struct {
	lk                sync.RWMutex
	self              peer.AddrInfo
	network           bsnet.BitSwapNetwork
	ObservedCids      map[cid.Cid]struct{}
	WantBlockFromPeer map[peer.ID]cid.Cid
}

func NewWantForwardExploiter(self peer.AddrInfo, network bsnet.BitSwapNetwork) *WantForwardExploiter {
	exploiter := &WantForwardExploiter{
		self:              self,
		network:           network,
		ObservedCids:      make(map[cid.Cid]struct{}),
		WantBlockFromPeer: make(map[peer.ID]cid.Cid),
	}

	return exploiter
}

func (wfe *WantForwardExploiter) ReceiveMessage(_ context.Context, sender peer.ID, incoming bsmsg.BitSwapMessage) {
	wfe.lk.Lock()
	defer wfe.lk.Unlock()

	for _, e := range incoming.Wantlist() {
		if e.WantType == bitswap_message_pb.Message_Wantlist_Block {
			wfe.observedWantBlock(sender, e.Cid)
		}
	}
	for _, e := range incoming.Forwardlist() {
		wfe.sendResponse(sender, e.Cid)
	}
}

func (wfe *WantForwardExploiter) observedWantBlock(sender peer.ID, c cid.Cid) {
	wfe.ObservedCids[c] = struct{}{}
	if _, ok := wfe.WantBlockFromPeer[sender]; !ok {
		wfe.WantBlockFromPeer[sender] = c
	}
}

func (wfe *WantForwardExploiter) sendResponse(p peer.ID, c cid.Cid) {
	message := bsmsg.New(false)
	message.AddForwardHave(c, []peer.AddrInfo{wfe.self})
	wfe.network.SendMessage(context.Background(), p, message)
}

func (wfe *WantForwardExploiter) ReceiveError(error) {}

func (wfe *WantForwardExploiter) PeerConnected(peer.ID) {}

func (wfe *WantForwardExploiter) PeerDisconnected(peer.ID) {}

// ensure WantForwardExploiter satisfies interface
var _ bsnet.Receiver = &WantForwardExploiter{}
